<!DOCTYPE html>
<html lang="ja">

<head>
  <meta charset="utf-8">
  <title>位置観測マップ</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <!-- Leaflet CSS -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css">

  <!-- Leaflet Routing Machine CSS -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet-routing-machine@3.2.12/dist/leaflet-routing-machine.css" />

  <!-- Leaflet 本体 (必ず Routing Machine より先) -->
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

  <!-- Routing Machine 本体 -->
  <script src="https://unpkg.com/leaflet-routing-machine@3.2.12/dist/leaflet-routing-machine.min.js"></script>

  <style>
    :root {
      --bg: #e8f0f8;
      --card: rgba(255, 255, 255, 0.95);
      --muted: #555;
      --accent: #1976d2;
      --danger: #e53935;
      --warning: #ff9800;
      --marker-border: #fff;
      --polyline-color: #ff4444;
      --polyline-weight: 5;
    }

    body {
      margin: 0;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, 'Helvetica Neue', Arial;
      background: var(--bg);
      color: #222;
    }

    #app {
      display: grid;
      grid-template-columns: 1fr 400px;
      gap: 12px;
      height: 100vh;
      padding: 12px;
      box-sizing: border-box;
    }

    #map {
      height: 100%;
      width: 100%;
      border-radius: 18px;
      /* iPhone風角丸 */
      overflow: hidden;
      box-shadow: 0 8px 25px rgba(0, 0, 0, 0.2);
      /* 立体感 */
      transition: transform 0.3s ease, box-shadow 0.3s ease;
      background: #f6f8fa;
      /* 読み込み中背景 */
    }

    /* ズームボタンをApple風に */
    .leaflet-control-zoom {
      border: none;
      background: rgba(255, 255, 255, 0.9);
      border-radius: 12px;
      box-shadow: 0 3px 10px rgba(0, 0, 0, 0.15);
    }

    .leaflet-control-zoom a {
      color: #1976d2;
      font-weight: bold;
    }

    .leaflet-touch .leaflet-bar a:first-child {
      border-top-left-radius: 10px;
      border-top-right-radius: 10px;
    }

    .leaflet-touch .leaflet-bar a:last-child {
      border-bottom-left-radius: 10px;
      border-bottom-right-radius: 10px;
    }



    .panel {
      position: relative;
      background: var(--card);
      padding: 14px;
      border-radius: 10px;
      box-shadow: 0 6px 16px rgba(0, 0, 0, 0.1);
      overflow: auto;
      display: flex;
      flex-direction: column;
      backdrop-filter: blur(5px);
    }

    h2 {
      margin: 6px 0 14px;
      font-size: 20px;
      color: var(--accent);
    }

    .info-grid {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 10px;
      margin-bottom: 14px;
    }

    .stat {
      background: #f9f9fb;
      padding: 3px;
      border-radius: 8px;
      font-size: 0.95em;
      text-align: center;
      box-shadow: 0 2px 6px rgba(0, 0, 0, 0.05);
    }

    .stat div {
      font-weight: 600;
      margin-top: 4px;
    }

    .controls {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));
      gap: 10px;
      margin-bottom: 14px;
    }

    button {
      background: var(--accent);
      color: #fff;
      border: none;
      padding: 3px;
      border-radius: 6px;
      cursor: pointer;
      font-size: 0.95em;
      transition: 0.2s;
    }

    button:hover {
      opacity: 0.85;
    }

    button.secondary {
      background: #666;
    }

    button.warning {
      background: var(--warning);
    }

    button.danger {
      background: var(--danger);
    }

    .row {
      display: flex;
      gap: 10px;
      align-items: center;
      font-size: 0.87em;
    }

    #log-container {
      /* ログ用スペースを確保 */
      height: 35vh;
      /* 最大展開高さ */
      min-height: 40px;
      /* 折りたたんだときの最小スペース */
      overflow: hidden;
      transition: height 0.5s ease;
    }

    #log {
      height: 100%;
      overflow: auto;
      padding: 8px;
      background: #f3f6fa;
      border-radius: 8px;
      box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.05);
      opacity: 1;
      transition: opacity 0.4s ease, padding 0.3s ease;
    }

    #log.collapsed {
      opacity: 0;
      padding-top: 0;
      padding-bottom: 0;
    }

    .log-entry {
      background: #f7f7f8;
      margin-bottom: 6px;
      padding: 10px;
      border-radius: 8px;
      box-shadow: 0 1px 5px rgba(0, 0, 0, 0.08);
    }

    .log-entry .time {
      font-weight: 600;
      margin-bottom: 4px;
      font-size: 0.85em;
      color: #333;
    }

    .log-entry .coords {
      font-size: 0.82em;
      color: #555;
      margin-bottom: 4px;
    }

    .log-entry .address {
      font-size: 0.87em;
      font-weight: 500;
      margin-bottom: 4px;
      word-break: break-word;
    }

    .log-entry .info {
      display: flex;
      gap: 8px;
      font-size: 0.82em;
    }

    .log-entry .accuracy {
      font-weight: 600;
    }

    .acc-green {
      color: green;
    }

    .acc-yellowgreen {
      color: yellowgreen;
    }

    .acc-orange {
      color: orange;
    }

    .acc-red {
      color: red;
    }

    @media(max-width:900px) {
      #app {
        grid-template-columns: 1fr;
        grid-template-rows: 65vh auto;
      }

      .panel {
        max-height: calc(100vh - 65vh);
      }

      .controls {
        grid-template-columns: repeat(auto-fit, minmax(80px, 1fr));
      }
    }

    .custom-marker div {
      border: 2px solid var(--marker-border);
      box-shadow: 0 0 5px rgba(0, 0, 0, 0.3);
      border-radius: 50%;
    }

    .leaflet-left {
      bottom: 50px;
    }

    .leaflet-bottom {
      bottom: 0px;
    }

    /* ルートのステップパネル */
    .leaflet-routing-container {
      display: flex;
      font-size: 12px;
      flex-direction: column;
      width: 200px;
      height: auto;
      /* 高さ固定 */
      background: rgba(255, 255, 255, 0.95);
      border-radius: 8px;
      padding: 6px;
      box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
      bottom: 50px;
      z-index: 998;
    }

    .leaflet-control-attribution {
      font-size: 10px;
      opacity: 0.8;
    }


    /* ヘッダ固定 */
    .leaflet-routing-container .leaflet-routing-header,
    .leaflet-routing-container .leaflet-routing-alternatives {
      flex: 0 0 auto;
    }

    /* ステップ一覧スクロール */
    .leaflet-routing-container .leaflet-routing-step-container {
      flex: 1 1 0;
      min-height: 0;
      overflow-y: auto;
    }

    /* 代替ルートの色分け（地図上） */
    .leaflet-routing-alt-line {
      opacity: 0.6;
      stroke-dasharray: 8, 4;
    }

    .leaflet-routing-alt h3 {
      display: none !important;
    }

    .leaflet-routing-collapse-btn {
      display: none !important;
    }

    .btn-pointer-none {
      background: silver !important;
      color: darkgray;
      pointer-events: none;
    }
  </style>
</head>

<body>
  <div id="app">
    <div id="map"></div>
    <div class="panel">
      <div style="display: flex; gap: 8px; margin-top: 8px;">
        <button id="navModeBtn" class="secondary">ナビ開始(車のみ)</button>
        <button id="cancelNavBtn" class="secondary">ナビ取り消し</button>
      </div>
      <div class="row">目的地までの所要時間: <span id="eta">---</span></div>
      <div class="row small address-row"
        style="flex-direction: column; align-items: flex-start; gap:2px; margin:0; padding:0;">
        <span style="font-weight:500; color:blue; line-height:1;">
          現在地住所:
          <span id="currentAddress"
            style="font-weight:600; word-break: break-word; line-height:1.2; color:blue;">---</span>
        </span>
        <span style="font-weight:500; color:#e53935; line-height:1; margin-top:4px;">
          目的地住所:
          <span id="destAddress"
            style="font-weight:600; word-break: break-word; line-height:1.2; color:#e53935;">---</span>
        </span>
      </div>

      <div class="row small">最終更新:<span id="lastAge" style="margin-left:8px">---</span></div>
      <h2>📍 位置観測マップ</h2>
      <div class="info-grid">
        <div class="stat">緯度: <div id="lat">---</div>
        </div>
        <div class="stat">経度: <div id="lng">---</div>
        </div>
        <div class="stat">精度: <div id="acc">---</div>
        </div>
        <div class="stat">高度: <div id="alt">---</div>
        </div>
        <div class="stat">速度: <div id="speed">---</div>
        </div>
        <div class="stat">方角: <div id="heading">---</div>
        </div>
      </div>

      <div style="height:8px"></div>
      <div class="controls">
        <button id="stopBtn" class="danger" onclick="btn_toggle()">観測停止</button>
        <button id="restartBtn" class="btn-pointer-none" onclick="btn_toggle()">再開</button>
        <button id="centerToggle" class="secondary">自動追尾: ON</button>
        <button id="exportJsonBtn" class="warning">JSON保存</button>
        <button id="exportCsvBtn" class="warning">CSV保存</button>
        <button id="clearBtn" class="secondary">ログ<br>経路クリア</button>
      </div>

      <script>
        function btn_toggle() {
          const stopBtn = document.getElementById('stopBtn');
          const restartBtn = document.getElementById('restartBtn');
          if (stopBtn.classList.contains('btn-pointer-none')) {
            stopBtn.classList.remove('btn-pointer-none');
            restartBtn.classList.add('btn-pointer-none');
          } else {
            stopBtn.classList.add('btn-pointer-none');
            restartBtn.classList.remove('btn-pointer-none');
          }
        }
      </script>

      <div class="row" style="margin:8px 0;gap:12px;align-items:center">
        <div>総距離: <strong id="totalDist">0 m</strong></div>
        <div>平均速度: <strong id="avgSpeed">0 km/h</strong></div>
      </div>

      <label id="logToggleLabel"
        style="display:flex; align-items:center; justify-content:space-between; cursor:pointer;">
        過去の位置情報ログ
        <button id="logToggleBtn" class="secondary" style="font-size:0.8em; padding:2px 6px;">▼</button>
      </label>
      <div id="log-container">
        <div id="log"></div>
      </div>

      <div style="margin-top:10px" class="small">※位置の取得は1秒以上間隔を空けています。</div>
    </div>
  </div>

  <script>
    let navMode = false;              // ナビモード ON/OFF
    let routingControl = null;        // ルーティングコントロール
    let currentDestination = null;    // 目的地を保持
    let userSelectedRoute = null;     // ユーザーが代替ルートを選択した場合に保持
    let startMarker = null;
    let userInteracting = false;
    let programMoving = false; // 追加
    let currentLabel = null;

    // ログUI
    const logToggleBtn = document.getElementById('logToggleBtn');
    const logContainer = document.getElementById('log');

    // ===== ログ折りたたみ =====
    logToggleBtn.addEventListener('click', () => {
      const logContainer = document.getElementById('log-container');
      const log = document.getElementById('log');
      log.classList.toggle('collapsed');

      if (log.classList.contains('collapsed')) {
        logContainer.style.minHeight = '40px';
        logContainer.style.height = '40px';
        logToggleBtn.textContent = '▲';
      } else {
        logContainer.style.height = '';
        logContainer.style.minHeight = '20vh';
        logToggleBtn.textContent = '▼';
      }

      const panel = document.querySelector('.panel');
      panel.scrollTo({ top: panel.scrollHeight, behavior: 'smooth' });
    });

    // ===== マップ・トラッキング初期化 =====
    let map, marker, watchId = null, pathSegments = [[]], polylines = [], logData = [];
    let lastFetchTime = 0, lastPosTime = 0, follow = true, lastOrientation = null;
    const LS_KEYS = { PATH: 'hp_map_path_v3', LOG: 'hp_map_log_v3' };

    // ===== マップ初期化 =====
    async function initMap() {
      // 仮の初期座標（東京駅など）を用意
      let initLat = 35.6812, initLng = 139.7671;
      let initialZoom = 17; // 初回ロード時のズーム

      let lastPath = null;

      // ローカルストレージに保存された最後の位置があればそれを使う
      try {
        lastPath = JSON.parse(localStorage.getItem(LS_KEYS.PATH));
        if (lastPath && lastPath.length && lastPath[lastPath.length - 1].length) {
          const lastPoint = lastPath[lastPath.length - 1].slice(-1)[0];
          if (lastPoint) {
            initLat = lastPoint[0];
            initLng = lastPoint[1];
            initialZoom = 17; // ローカル復元でも初回ズーム
          }
        }
      } catch (e) { console.warn('ローカル復元失敗', e); }

      // ===== マップ作成（iPhoneマップ風のスタイル） =====
      map = L.map('map', {
        zoomAnimation: true,          // ズームを滑らかに
        fadeAnimation: true,          // タイル切り替えをフェードで
        markerZoomAnimation: true,    // マーカー拡大縮小アニメ
        inertia: true,                // スワイプ慣性
        inertiaDeceleration: 2500,    // 慣性の減衰（iPhoneっぽく）
        zoomControl: false,           // デフォルトズームUIを隠す
        attributionControl: false,    // 著作権表記を下に移す
      }).setView([initLat, initLng], initialZoom);

      // 高精細（Retina対応）タイル読み込み
      L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        maxZoom: 19,
        detectRetina: false,
        attribution: '© OpenStreetMap contributors'
      }).addTo(map);

      // iPhoneの右下ズームボタン風に再配置
      L.control.zoom({ position: 'topleft' }).addTo(map);

      // 下部にスッキリと著作権表記
      L.control.attribution({ position: 'bottomleft' }).addTo(map);


      // ドラッグやズーム開始時にユーザー操作フラグを立てる
      map.on('dragstart zoomstart', () => {
        if (!programMoving) { // プログラム移動中は無視
          userInteracting = true;
        }
        if (currentLabel) {
          currentLabel.remove();
          currentLabel = null;
        }
      });

      // ドラッグやズーム終了時にユーザー操作ならOFF
      map.on('dragend zoomend', () => {
        if (userInteracting) {
          follow = false;
          document.getElementById('centerToggle').textContent = '自動追尾: OFF';
          userInteracting = false;
        }
      });

      // ローカル座標がなければ現在地取得して初回表示
      if (!lastPath || !lastPath.length) {
        if (navigator.geolocation) {
          navigator.geolocation.getCurrentPosition(pos => {
            const { latitude, longitude } = pos.coords;
            // 初回だけズームレベル17で表示
            map.setView([latitude, longitude], 17);
          });
        }
      }
    }


    // ===== ユーティリティ =====
    const toFixedOrDash = (v, d = 6) => typeof v === 'number' ? v.toFixed(d) : '---';
    const now = () => Date.now();
    const haversine = (a, b) => {
      const R = 6371e3, toRad = d => d * Math.PI / 180;
      const φ1 = toRad(a[0]), φ2 = toRad(b[0]);
      const Δφ = toRad(b[0] - a[0]), Δλ = toRad(b[1] - a[1]);
      const aa = Math.sin(Δφ / 2) ** 2 + Math.cos(φ1) * Math.cos(φ2) * Math.sin(Δλ / 2) ** 2;
      return R * 2 * Math.atan2(Math.sqrt(aa), Math.sqrt(1 - aa));
    };
    const directionName = deg => {
      if (deg === null || isNaN(deg)) return '---';
      const dirs = ['北', '北東', '東', '南東', '南', '南西', '西', '北西'];
      return `${dirs[Math.round(deg / 45) % 8]} (${deg.toFixed(0)}°)`;
    };

    // ===== 距離・速度計算 =====
    function calcTotalDistance() {
      return pathSegments.flatMap(seg => seg.slice(1).map((_, i) => haversine(seg[i], seg[i + 1]))).reduce((a, b) => a + b, 0);
    }
    function calcAvgSpeed() {
      if (logData.length < 2) return 0;
      const first = new Date(logData[logData.length - 1]?.time || now()).getTime();
      const last = new Date(logData[0]?.time || now()).getTime();
      const dt = Math.abs(last - first) / 1000;
      return dt <= 0 ? 0 : (calcTotalDistance() / dt) * 3.6;
    }
    function updateStatsUI() {
      document.getElementById('totalDist').textContent = (calcTotalDistance() / 1000).toFixed(3) + ' km';
      document.getElementById('avgSpeed').textContent = calcAvgSpeed().toFixed(2) + ' km/h';
    }

    // ===== 保存・復元 =====
    function safeSaveLocal() {
      try {
        localStorage.setItem(LS_KEYS.PATH, JSON.stringify(pathSegments));
        localStorage.setItem(LS_KEYS.LOG, JSON.stringify(logData));
      } catch { }
    }
    function restoreLocal() {
      try {
        const rawP = localStorage.getItem(LS_KEYS.PATH);
        const rawL = localStorage.getItem(LS_KEYS.LOG);
        if (rawP) pathSegments = JSON.parse(rawP);
        if (rawL) logData = JSON.parse(rawL);
        logData.slice(0, 200).forEach(e => addLogEntry(e, true));
      } catch { }
    }

    // ===== ポリライン =====
    function yellowgreenrawPolylines() {
      const lastSeg = pathSegments[pathSegments.length - 1];
      if (!lastSeg || lastSeg.length === 0) return;

      let lastLine = polylines[polylines.length - 1];
      if (!lastLine || lastLine.getLatLngs().length === 0) {
        lastLine = L.polyline(lastSeg, { color: '#9ACD32', weight: 6, opacity: 0.8 }).addTo(map);
        polylines.push(lastLine);
      } else {
        lastLine.addLatLng(lastSeg[lastSeg.length - 1]);
      }
    }

    // ===== マーカー更新 =====
    function updateMarker(lat, lng, heading, accColor, speedKmh) {
      const size = speedKmh && speedKmh * 3.6 > 200 ? 20 : 16;
      if (lat === null || lng === null || accColor === null) accColor = 'black';

      // null が渡されたらマーカー削除して終了（次の有効座標で再作成）
      if (lat === null || lng === null) {
        if (marker) {
          try { map.removeLayer(marker); } catch (e) { /* ignore */ }
          marker = null;
        }
        return;
      }

      // イージング（ローカル関数、グローバルは増やさない）
      function easeOutQuad(t) { return t * (2 - t); }

      // 初回作成
      if (!marker) {
        const icon = L.divIcon({
          className: 'custom-marker',
          html: `<div style="width:${size}px;height:${size}px;background:${accColor};border:2px solid #fff;border-radius:50%;transform:rotate(${heading}deg)"></div>`,
          iconSize: [size, size],
          iconAnchor: [size / 2, size / 2]
        });
        marker = L.marker([lat, lng], { icon }).addTo(map);
        // アニメ管理用プロパティを付与
        marker._animId = null;
        marker._lastHeading = (typeof heading === 'number') ? heading : 0;
        marker._lastPos = marker.getLatLng();

        marker.on("click", e => {
          showMarkerLabelLeaflet(e, "現在地");
        });
        map.on("click", () => {
          if (currentLabel) {
            currentLabel.remove();
            currentLabel = null;
          }
        });
        return;
      }

      // 要素（div）取得（存在しない場面があるため安全に）
      const el = marker.getElement && marker.getElement();
      const div = el ? el.querySelector('div') : null;

      // 見た目（色・サイズ）を即時更新
      if (div) {
        div.style.width = div.style.height = size + 'px';
        div.style.background = accColor;
        div.style.borderRadius = '50%';
      }

      // 既存アニメがあればキャンセル
      if (marker._animId) {
        cancelAnimationFrame(marker._animId);
        marker._animId = null;
      }

      // 補間開始値と終了値
      const from = marker.getLatLng();
      const fromLat = from.lat, fromLng = from.lng;
      const fromHeading = (marker._lastHeading === undefined) ? 0 : marker._lastHeading;
      const toLat = lat, toLng = lng;
      const toHeading = (typeof heading === 'number') ? heading : fromHeading;

      // 角度差を -180..180 に正規化（360回り込み対策）
      let delta = toHeading - fromHeading;
      if (delta > 180) delta -= 360;
      if (delta < -180) delta += 360;

      const duration = 400; // ms（見た目の好みで 300-800 に調整可）
      const startTime = performance.now();

      function step(now) {
        const t = Math.min(1, (now - startTime) / duration);
        const e = easeOutQuad(t);

        const curLat = fromLat + (toLat - fromLat) * e;
        const curLng = fromLng + (toLng - fromLng) * e;
        marker.setLatLng([curLat, curLng]);

        if (div) {
          const curHead = fromHeading + delta * e;
          div.style.transform = `rotate(${curHead}deg)`;
        }

        if (t < 1) {
          marker._animId = requestAnimationFrame(step);
        } else {
          marker._animId = null;
          marker._lastHeading = toHeading;
          marker._lastPos = marker.getLatLng();
        }
      }

      marker._animId = requestAnimationFrame(step);
    }

    function showMarkerLabelLeaflet(e, text) {
      // 既存ラベル削除
      if (currentLabel) {
        currentLabel.remove();
        currentLabel = null;
      }

      // Leaflet のマップ座標 → DOM 座標
      const point = map.mouseEventToContainerPoint(e.originalEvent);

      const label = document.createElement('div');
      label.textContent = text;
      label.style.position = 'absolute';
      label.style.background = 'rgba(0,0,0,0.7)';
      label.style.color = 'white';
      label.style.padding = '2px 5px';
      label.style.borderRadius = '4px';
      label.style.fontSize = '15px';
      label.style.pointerEvents = 'none';
      label.style.zIndex = 1000;

      label.style.left = (point.x + 20) + 'px';
      label.style.top = (point.y - 20) + 'px';

      document.body.appendChild(label);
      currentLabel = label;
    }

    // ===== 住所取得 =====
    async function fetchAddress(lat, lng) {
      // 取得間隔制御（1秒以内は再取得しない）
      if (now() - lastFetchTime < 1000) return '取得間隔制御中';

      // 近接チェック（直前取得地点と近い場合は既存表示を返す）
      try {
        if (marker && lastRoutePoint && haversine([lat, lng], lastRoutePoint) < 10) {
          const curEl = document.getElementById('currentAddress') || document.getElementById('destAddress');
          if (curEl && curEl.textContent && curEl.textContent !== '---') return curEl.textContent;
        }
      } catch (e) {
        console.warn('近接チェック例外', e);
      }

      lastFetchTime = now();

      try {
        // Nominatim 逆ジオコーディング
        const res = await fetch(`https://nominatim.openstreetmap.org/reverse?lat=${lat}&lon=${lng}&format=json&accept-language=ja`);
        if (!res.ok) return '住所取得失敗';
        const data = await res.json();
        const a = data.address || {};

        // 日本都道府県リスト
        const jpPrefs = [
          '北海道', '青森県', '岩手県', '宮城県', '秋田県', '山形県', '福島県',
          '茨城県', '栃木県', '群馬県', '埼玉県', '千葉県', '東京都', '神奈川県',
          '新潟県', '富山県', '石川県', '福井県', '山梨県', '長野県', '岐阜県', '静岡県', '愛知県',
          '三重県', '滋賀県', '京都府', '大阪府', '兵庫県', '奈良県', '和歌山県',
          '鳥取県', '島根県', '岡山県', '広島県', '山口県',
          '徳島県', '香川県', '愛媛県', '高知県',
          '福岡県', '佐賀県', '長崎県', '熊本県', '大分県', '宮崎県', '鹿児島県', '沖縄県'
        ];

        // address 内の全フィールド + display_name を結合
        let joined = Object.values(a).filter(Boolean).join(' ');
        if (data.display_name) joined += ' ' + data.display_name;

        // 都道府県抽出
        let prefecture = '';
        const regex = new RegExp(jpPrefs.join('|'));
        const match = joined.match(regex);
        if (match) {
          prefecture = match[0];
        } else {
          // 短縮名（東京→東京都）で検索
          for (const full of jpPrefs) {
            const short = full.replace(/(都|道|府|県)$/, '');
            if (short && joined.includes(short)) {
              prefecture = full;
              break;
            }
          }
        }

        // display_name から番地・建物を補完（郵便番号は除外）
        if (!a.house_number || !a.building) {
          const parts = (data.display_name || '').split(',').map(s => s.trim());
          // 番地補完（数字組み合わせだが郵便番号は除外）
          if (!a.house_number) {
            const hn = parts.find(p => /\d{1,4}(-\d{1,4})*/.test(p) && !/\d{3}-\d{4}/.test(p));
            if (hn) a.house_number = hn;
          }
          // 建物名補完（ビル・マンションなど）
          if (!a.building) {
            const bd = parts.find(p => /ビル|マンション|ハイツ|アパート/.test(p));
            if (bd) a.building = bd;
          }
        }

        // 返却順序：国, 郵便, 都道府県, 市町村, 町域, 道路, 番地, 建物名
        const result = [
          a.country,
          a.postcode,      // ここは address のみ使用
          prefecture,
          a.city || a.town || a.village,
          a.suburb || a.neighbourhood,
          a.road,
          a.house_number,
          a.building
        ].filter(Boolean).join(', ');

        return result || data.display_name || '住所情報なし';

      } catch (err) {
        console.warn('fetchAddress error', err);
        return '住所取得エラー';
      }
    }

    // ===== ログ表示 =====
    function addLogEntry(e, restoreMode = false) {
      if (!restoreMode) logData.unshift(e);
      const accClass = e.accuracy < 5 ? 'acc-green' : e.accuracy < 15 ? 'acc-yellowgreen' : e.accuracy < 30 ? 'acc-orange' : 'acc-red';
      const html = `<div class="log-entry">
    <div class="time">🕒 ${new Date(e.time).toLocaleString()}</div>
    <div class="coords">(${e.lat.toFixed(6)}, ${e.lng.toFixed(6)})</div>
    <div class="address">📍 ${e.address}</div>
    <div class="info">
      <div class="accuracy ${accClass}">精度:${e.accuracy.toFixed(1)}m</div>
      <div>速度:${e.speedText}</div>
      <div>方角:${e.headingText}</div>
    </div>
  </div>`;
      const logElem = document.getElementById('log');
      logElem.insertAdjacentHTML('afterbegin', html);
      // while を使わず、一度に削除して高速化
      if (logElem.childElementCount > 200) logElem.removeChild(logElem.lastChild);
      if (!restoreMode) { safeSaveLocal(); updateStatsUI(); }
    }

    // ===== ダウンロード =====
    function download(filename, text) {
      const a = document.createElement('a');
      a.href = URL.createObjectURL(new Blob([text], { type: 'text/plain' }));
      a.download = filename;
      a.click();
    }
    document.getElementById('exportJsonBtn').addEventListener('click', () => download('location_log.json', JSON.stringify({ pathSegments, logData, savedAt: new Date().toISOString() }, null, 2)));
    document.getElementById('exportCsvBtn').addEventListener('click', () => {
      const h = ['time,lat,lng,accuracy,speed_kmh,heading,address'];
      const rows = logData.map(e => `${JSON.stringify(e.time)},${e.lat},${e.lng},${e.accuracy},${parseFloat(e.speedKmh) || ''},${JSON.stringify(e.headingText)},${JSON.stringify(e.address)}`);
      download('location_log.csv', h.concat(rows).join('\n'));
    });

    // ===== 操作ボタン =====
    document.getElementById('stopBtn').addEventListener('click', () => { if (watchId) { navigator.geolocation.clearWatch(watchId); watchId = null; pathSegments.push([]); } });
    document.getElementById('restartBtn').addEventListener('click', () => { if (!watchId) startTracking(); });
    document.getElementById('clearBtn').addEventListener('click', () => { if (confirm('本当にクリアしますか？')) { pathSegments = [[]]; logData = []; yellowgreenrawPolylines(); document.getElementById('log').innerHTML = ''; safeSaveLocal(); updateStatsUI(); } });
    document.getElementById('centerToggle').addEventListener('click', async () => {
      follow = !follow;
      document.getElementById('centerToggle').textContent = `自動追尾: ${follow ? 'ON' : 'OFF'}`;

      if (follow && marker) {
        const pos = marker.getLatLng();

        // プログラム移動中フラグON
        programMoving = true;

        // 現在地にアニメーションで移動＆ズーム
        map.flyTo(pos, 17, { animate: true, duration: 1.2 });

        // flyToアニメーション終了後にフラグを解除
        map.once('moveend', () => {
          programMoving = false;
        });

        // 現在地の住所を更新
        const addr = await fetchAddress(pos.lat, pos.lng);
        document.getElementById('currentAddress').textContent = addr;

        // 追尾中はユーザー操作でズーム・パン可能
        map.dragging.enable();
        map.touchZoom.enable();
        map.scrollWheelZoom.enable();
        map.doubleClickZoom.enable();
        map.boxZoom.enable();
        map.keyboard.enable();
      }
    });

    // ===== 位置更新 =====
    let lastRouteUpdate = 0;
    let lastRoutePoint = null;
    let lastAddressTime = 0;
    const MIN_ACCURACY = 40; // 精度40m以上は無視
    let firstPositionReceived = false; // 初回位置フラグ
    const SMOOTHING_COUNT = 2; // 平滑化点数
    let smoothBuffer = [];

    async function handlePosition(pos) {
      if (!pos || !pos.coords) {
        updateMarker(null, null, 0, 'black', 0);
        return;
      }

      const c = pos.coords;
      const lat = c.latitude, lng = c.longitude, acc = c.accuracy || 0, alt = c.altitude;
      let speed = (c.speed >= 0) ? c.speed : null;
      let heading = (typeof c.heading === 'number') ? c.heading : null;
      const nowTime = Date.now();

      const lastSegment = pathSegments[pathSegments.length - 1];
      const prev = lastSegment ? lastSegment.slice(-1)[0] : null;
      const isFirst = !firstPositionReceived;
      if (isFirst) firstPositionReceived = true;

      // 精度チェック
      if (!isFirst && acc > MIN_ACCURACY) return;

      // 速度・方角補正
      if (prev) {
        const dt = (pos.timestamp - lastPosTime) / 1000;
        if ((!speed || speed === 0) && dt > 0) speed = haversine(prev, [lat, lng]) / dt;
        if ((heading === null || isNaN(heading)) && dt > 0) {
          heading = Math.atan2(lng - prev[1], lat - prev[0]) * 180 / Math.PI;
          if (heading < 0) heading += 360;
        }
      }
      if (lastOrientation !== null) heading = lastOrientation;
      heading = (heading === null || isNaN(heading)) ? 0 : heading;

      const accColor = acc < 5 ? 'green' : acc < 15 ? 'yellowgreen' : acc < 30 ? 'orange' : 'red';

      // ===== UI更新 =====
      document.getElementById('lat').textContent = toFixedOrDash(lat, 6);
      document.getElementById('lng').textContent = toFixedOrDash(lng, 6);
      document.getElementById('acc').textContent = `${acc.toFixed(1)} m`;
      document.getElementById('alt').textContent = alt === null ? '---' : `${alt.toFixed(1)} m`;
      document.getElementById('speed').textContent = speed ? `${(speed * 3.6).toFixed(1)} km/h` : '---';
      document.getElementById('heading').textContent = directionName(heading);
      document.getElementById('acc').style.color = accColor;

      // ===== 平滑化 + 低精度補正 =====
      if (isFirst || acc <= MIN_ACCURACY || (prev && haversine(prev, [lat, lng]) > 5)) {
        smoothBuffer.push([lat, lng]);
        if (smoothBuffer.length > SMOOTHING_COUNT) smoothBuffer.shift();

        let smoothed = [
          smoothBuffer.reduce((sum, p) => sum + p[0], 0) / smoothBuffer.length,
          smoothBuffer.reduce((sum, p) => sum + p[1], 0) / smoothBuffer.length
        ];

        if (marker) {
          const prevMarkerPos = [marker.getLatLng().lat, marker.getLatLng().lng];
          const d = haversine(prevMarkerPos, smoothed);
          const MAX_STEP = Math.max(5, acc / 2); // ← 歩行レベルの動きを自然に反映
          if (d > MAX_STEP) {
            const ratio = MAX_STEP / d;
            smoothed = [
              prevMarkerPos[0] + (smoothed[0] - prevMarkerPos[0]) * ratio,
              prevMarkerPos[1] + (smoothed[1] - prevMarkerPos[1]) * ratio
            ];
          }
        }

        const smoothDist = prev ? haversine(prev, smoothed) : Infinity;
        const threshold = Math.max(1.5, acc / 2); // ← 小移動（2〜3m）でも更新される

        if (!marker || !prev || smoothDist > threshold || isFirst) {
          let lastSegment = pathSegments[pathSegments.length - 1];
          if (!lastSegment || lastSegment.length === 0) {
            pathSegments.push([]);
            lastSegment = pathSegments[pathSegments.length - 1];
          }
          lastSegment.push(smoothed);
          yellowgreenrawPolylines();
          updateMarker(smoothed[0], smoothed[1], heading, accColor, speed);

          //自動追尾ONなら現在地を中心にマップも追尾します。
          if (follow && map && !userInteracting) {
            programMoving = true;
            map.panTo(smoothed, { animate: true, duration: 0.5 });
            map.once('moveend', () => programMoving = false);
          }

          // 初回だけマップ中心をセット
          if (isFirst && map) {
            map.setView(smoothed, 17);
          }
        }
      }

      // ===== 住所更新 =====
      const currentAddrElem = document.getElementById('currentAddress');
      if (nowTime - lastAddressTime > 1000) {
        const addrLat = lat, addrLng = lng;
        fetchAddress(addrLat, addrLng).then(addr => {
          if (lat === addrLat && lng === addrLng) {
            currentAddrElem.textContent = addr; // 現在地住所のみ更新
          }
        });
        lastAddressTime = nowTime;
      }

      // ===== ログ追加 =====
      addLogEntry({
        time: new Date().toISOString(),
        lat, lng, accuracy: acc, altitude: alt,
        speedKmh: speed ? speed * 3.6 : null,
        speedText: speed ? `${(speed * 3.6).toFixed(1)} km/h` : '---',
        headingText: directionName(heading),
        address: currentAddrElem.textContent
      });

      // ===== ナビ中ルート更新 =====
      const current = [lat, lng];
      if (routingControl && currentDestination && !userSelectedRoute) {
        const distMoved = lastRoutePoint ? haversine(lastRoutePoint, current) : Infinity;

        if (distMoved > 30 && nowTime - lastRouteUpdate > 5000 && !routingControl._routingInProgress) {
          routingControl._routingInProgress = true;
          routingControl.setWaypoints([L.latLng(lat, lng), currentDestination]);
          // ルート完了時にフラグ解除
          routingControl.on('routesfound routingerror', () => {
            routingControl._routingInProgress = false;
          });

          // 次ステップ表示
          const route = routingControl.getPlan().getWaypoints();
          if (route?.length >= 2) {
            const nextStep = `次: ${route[1].lat.toFixed(5)},${route[1].lng.toFixed(5)}`;
            const stepDiv = document.getElementById('nextStep') || document.createElement('div');
            stepDiv.id = 'nextStep';
            stepDiv.style.fontWeight = '600';
            stepDiv.textContent = nextStep;
            document.querySelector('.panel').appendChild(stepDiv);
          }

          lastRoutePoint = current;
          lastRouteUpdate = nowTime;
        }

        // リアルタイムETA
        if (speed && speed > 0) {
          const distToDest = haversine(current, [currentDestination.lat, currentDestination.lng]);
          const timeSec = distToDest / speed;
          const hours = Math.floor(timeSec / 3600);
          const minutes = Math.round((timeSec % 3600) / 60);
          let timeText = '';
          if (hours > 0) timeText += `${hours}時間`;
          timeText += `${minutes}分`;
          document.getElementById('eta').textContent = `${(distToDest / 1000).toFixed(2)} km / 約 ${timeText}`;
        } else {
          document.getElementById('eta').textContent = '---';
        }
      }

      // ===== スタートマーカー追従 =====
      if (routingControl && currentDestination && startMarker) {
        const markerPos = smoothBuffer.length ? smoothed : [lat, lng];
        startMarker.setLatLng(markerPos);
      }

      lastPosTime = pos.timestamp || now();
      document.getElementById('lastAge').textContent = '0秒前';
    }


    // ===== エラー処理 =====
    let retryTimer = null;
    function handleError(err) { console.warn('位置取得エラー', err); if (!retryTimer) retryTimer = setTimeout(() => { startTracking(); }, 3000); }

    // ===== 追跡開始 =====
    async function startTracking() {
      if (!navigator.geolocation) { alert('位置情報未対応'); return; }

      // 初回取得（低精度で即時表示）
      navigator.geolocation.getCurrentPosition(
        pos => handlePosition(pos),
        err => console.warn('初回取得失敗', err),
        { enableHighAccuracy: false, timeout: 5000, maximumAge: 5000 }
      );

      // 継続追跡（高精度）
      watchId = navigator.geolocation.watchPosition(
        pos => handlePosition(pos),
        err => console.warn('追跡取得エラー', err),
        { enableHighAccuracy: true, timeout: 10000, maximumAge: 0 }
      );
    }

    // ===== 更新時間表示 =====
    setInterval(() => {
      if (lastPosTime) {
        const deltaSec = Math.floor((now() - lastPosTime) / 1000);
        const h = Math.floor(deltaSec / 3600), m = Math.floor((deltaSec % 3600) / 60), s = deltaSec % 60;
        let text = '';
        if (h > 0) text += `${h}時間`;
        if (m > 0 || h > 0) text += `${m}分`;
        text += `${s}秒前`;
        document.getElementById('lastAge').textContent = text;
      }
    }, 1000);

    // ===== DeviceOrientation =====
    async function setupDeviceOrientation() {
      if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
        const btn = document.createElement('button');
        btn.textContent = 'コンパス許可';
        btn.className = 'warning';
        btn.style.margin = '6px';
        document.querySelector('.panel').appendChild(btn);
        btn.addEventListener('click', async () => {
          const perm = await DeviceOrientationEvent.requestPermission();
          if (perm === 'granted') { window.addEventListener('deviceorientationabsolute', onDeviceOrientation); btn.remove(); } else alert('拒否');
        });
      } else if (window.DeviceOrientationEvent) window.addEventListener('deviceorientationabsolute', onDeviceOrientation);
    }
    function onDeviceOrientation(e) {
      if (e && typeof e.alpha === 'number') {
        lastOrientation = (360 - e.alpha) % 360;
        document.getElementById('heading').textContent = directionName(lastOrientation);
        if (marker && marker.getElement()) {
          const div = marker.getElement().querySelector('div');
          if (div) div.style.transform = `rotate(${lastOrientation}deg)`;
        }
      }
    }


    const instructionMap = {
      "Destination": "目的地",
      "Arrive at destination": "目的地に到着",
      "Start": "出発地点",
      "Merge": "合流",
      "U-turn": "Uターン",
      "Via": "経由",
      "on": "上",
      "toward": "方面",
      "heading": "方向",
      "north": "北",
      "south": "南",
      "east": "東",
      "west": "西",
      "the left": "左側",
      "the right": "右側",
      "left": "左",
      "right": "右",
      "onto": "上に"
    };

    const patterns = [
      // ラウンドアバウト
      { re: /^Enter roundabout/i, replace: "ロータリーに入る" },
      { re: /^Exit roundabout/i, replace: "ロータリーを出る" },
      { re: /^Roundabout with (\d+) exits/i, replace: (m) => `ロータリー（${m[1]}出口）` },

      // Turn + direction + onto + road
      { re: /^Turn (?:the )?(left|right) onto (.+)/i, replace: (m) => `${m[2]} に${m[1].toLowerCase() === "left" ? "左折" : "右折"}で合流` },

      // right/left onto 単体対応（Turnなし）
      { re: /^(?:the )?(left|right) onto (.+)/i, replace: (m) => `${m[2]} に${m[1].toLowerCase() === "left" ? "左折" : "右折"}で合流` },

      // Make a + Sharp/Slight + direction
      { re: /make a sharp left/i, replace: "鋭角に左折" },
      { re: /make a sharp right/i, replace: "鋭角に右折" },
      { re: /make a slight left/i, replace: "やや左方向" },
      { re: /make a slight right/i, replace: "やや右方向" },

      // 左右折単体
      { re: /^Turn (left|right)/i, replace: (m) => m[1].toLowerCase() === "left" ? "左折" : "右折" },
      { re: /^Slight (left|right)/i, replace: (m) => "やや" + (m[1].toLowerCase() === "left" ? "左" : "右") + "方向" },
      { re: /^Sharp (left|right)/i, replace: (m) => "鋭角に" + (m[1].toLowerCase() === "left" ? "左" : "右") + "折" },
      { re: /^Keep (left|right)/i, replace: (m) => m[1].toLowerCase() === "left" ? "左側を維持" : "右側を維持" },

      // Take the ramp / Take the exit
      { re: /^Take (?:the )?ramp(?: to (.+))?/i, replace: (m) => m[1] ? `${m[1]} にランプで合流` : "ランプで合流" },
      { re: /^Take (?:the )?exit (\d+)(?: to (.+))?/i, replace: (m) => m[2] ? `${m[2]} に${m[1]}出口で合流` : `${m[1]}出口で合流` },

      // 分岐点
      { re: /at the fork/i, replace: "分岐点で" },

      // 進行方向・head対応
      { re: /^head (\w+)/i, replace: (m) => `${m[1]} 方向に進む` },
      { re: /^Head (\w+)/i, replace: (m) => `${m[1]} 方向に進む` },
      { re: /heading (\w+)/i, replace: (m) => `${m[1]} 方向に進む` },

      // 進行方向単体
      { re: /^Continue/i, replace: "直進" },
      { re: /Go straight/i, replace: "直進" },
      { re: /Proceed/i, replace: "直進" },

      // 信号・交差点
      { re: /At traffic light/i, replace: "信号で" },
      { re: /At intersection/i, replace: "交差点で" },
      { re: /Turn at junction/i, replace: "交差点で曲がる" }
    ];

    function translateInstructions(route) {
      if (!route.instructions) return;

      route.instructions.forEach(instr => {
        let text = instr.text;

        // 文章をフレーズに分割
        const parts = text.split(/,|then|and/i).map(p => p.trim()).filter(p => p);

        const translatedParts = parts.map(part => {
          let t = part;

          // 目的地到着
          if (/You have arrived at your/i.test(t)) return "目的地に到着です";

          // right/left onto 単体対応（Turnなし）
          let match = t.match(/^(?:the )?(left|right) onto (.+)/i);
          if (match) return `${match[2]}に${match[1].toLowerCase() === "left" ? "左折" : "右折"}してください`;

          // Turn + left/right onto
          match = t.match(/^Turn (?:the )?(left|right) onto (.+)/i);
          if (match) return `${match[2]}に${match[1].toLowerCase() === "left" ? "左折" : "右折"}してください`;

          // Take the ramp（入口）
          match = t.match(/^Take (?:the )?ramp(?: to (.+))?/i);
          if (match) {
            const road = match[1];
            if (!road) return "道路に入ります"; // 道路名が無い場合の汎用表現
            if (/I-|Highway/i.test(road)) return `${road}高速に入ります`;
            if (/Route/i.test(road)) return `国道${road.replace(/\D/g, '')}号に入ります`;
            if (/Prefectural Road/i.test(road)) return `県道${road.replace(/\D/g, '')}号に入ります`;
            return `${road}に入ります`; // 一般道路
          }

          // Take the exit（出口）
          match = t.match(/^Take (?:the )?exit (\d+)(?: to (.+))?/i);
          if (match) {
            const exitNum = match[1];
            const road = match[2];
            if (!road) return `${exitNum}番出口で降ります`; // 道路名なしの場合
            if (/I-|Highway/i.test(road)) return `${exitNum}番出口で降りて${road}高速に入ります`;
            if (/Route/i.test(road)) return `${exitNum}番出口で降りて国道${road.replace(/\D/g, '')}号に入ります`;
            if (/Prefectural Road/i.test(road)) return `${exitNum}番出口で降りて県道${road.replace(/\D/g, '')}号に入ります`;
            return `${exitNum}番出口で降りて${road}に入ります`; // 一般道路
          }

          // Enter + 道路名
          match = t.match(/^Enter (.+)/i);
          if (match) return `${match[1]}に入ります`;

          // head / heading + 方角
          match = t.match(/^(head|Head|heading) (\w+)/i);
          if (match) {
            const dirMap = { north: "北", south: "南", east: "東", west: "西" };
            const dirJa = dirMap[match[2].toLowerCase()] || match[2];
            return `${dirJa}方向に進みます`;
          }

          // straight ahead
          if (/straight ahead/i.test(t)) return "直進してください";

          // パターンルール
          for (const p of patterns) {
            const m = t.match(p.re);
            if (m) {
              const replaced = typeof p.replace === "function" ? p.replace(m) : p.replace;
              return replaced.replace(/方向$/, "方向に進みます");
            }
          }

          // 単語置換
          Object.entries(instructionMap)
            .sort((a, b) => b[0].length - a[0].length)
            .forEach(([en, ja]) => {
              const re = new RegExp(`\\b${en}\\b`, 'gi');
              t = t.replace(re, ja);
            });

          return t;
        });

        // 自然な接続語で結合
        instr.text = translatedParts.join("。次に、");
      });
    }

    // ===== 初期ロード =====
    window.addEventListener('load', () => {
      initMap();
      restoreLocal();
      yellowgreenrawPolylines();
      setupDeviceOrientation();
      startTracking();

      const navModeBtn = document.getElementById("navModeBtn");

      // ナビモード切替
      navModeBtn.addEventListener("click", () => {
        navMode = !navMode;
        navModeBtn.textContent = navMode ? "地図クリックで目的地を選択中…" : "ナビ開始(車のみ)";
      });

      // ===== アニメーション用ポリライン管理 =====
      let animatedPolylines = []; // {polyline, route}
      let routingControl = null;
      let currentDestination = null;
      let userSelectedRoute = false;

      // ===== スムーズアニメーション関数 =====
      function animateRouteSmooth(latlngs, color = "#1976d2", weight = 7, duration = 2000) {
        if (!latlngs || latlngs.length < 2) return;

        // ---- 軽量化：5〜10mごとにサンプリング ----
        const simplified = [latlngs[0]];
        for (let i = 1; i < latlngs.length; i++) {
          const prev = simplified[simplified.length - 1];
          const dist = map.distance(prev, latlngs[i]);
          if (dist > 8) simplified.push(latlngs[i]); // ← 距離を短めに
        }
        simplified.push(latlngs[latlngs.length - 1]);

        // ---- 線を追加 ----
        const polyline = L.polyline([simplified[0]], { color, weight, opacity: 1 }).addTo(map);

        // 総距離
        let totalDist = 0;
        const segDist = [];
        for (let i = 0; i < simplified.length - 1; i++) {
          const d = map.distance(simplified[i], simplified[i + 1]);
          segDist.push(d);
          totalDist += d;
        }

        let startTime = null;

        function step(ts) {
          if (!startTime) startTime = ts;
          const elapsed = ts - startTime;
          const progress = Math.min(elapsed / duration, 1);
          const targetDist = totalDist * progress;

          // 現在までの距離に応じてどこまで描くか計算
          let traveled = 0;
          const points = [simplified[0]];

          for (let i = 0; i < segDist.length; i++) {
            if (traveled + segDist[i] >= targetDist) {
              // 区間内の補間
              const remain = targetDist - traveled;
              const ratio = remain / segDist[i];
              const a = simplified[i], b = simplified[i + 1];
              const interp = L.latLng(
                a.lat + (b.lat - a.lat) * ratio,
                a.lng + (b.lng - a.lng) * ratio
              );
              points.push(interp);
              break;
            } else {
              points.push(simplified[i + 1]);
              traveled += segDist[i];
            }
          }

          polyline.setLatLngs(points);
          if (progress < 1) requestAnimationFrame(step);
        }

        requestAnimationFrame(step);
        return polyline;
      }

      // ===== ETA更新関数 =====
      function updateEta(route) {
        if (!route || !route.summary) return;
        const summary = route.summary;
        if (!summary.totalDistance || !summary.totalTime) return;
        const distKm = (summary.totalDistance / 1000).toFixed(2);
        let totalSec = summary.totalTime;
        const hours = Math.floor(totalSec / 3600);
        const minutes = Math.round((totalSec % 3600) / 60);
        let timeText = '';
        if (hours > 0) timeText += `${hours}時間`;
        timeText += `${minutes}分`;
        document.getElementById("eta").textContent = `${distKm} km / 約 ${timeText}`;
      }

      // ===== マップクリックで目的地選択 =====
      map.on("click", async e => {
        if (!navMode) return;
        if (!marker) {
          alert("現在地を取得中です。位置が確定したらもう一度クリックしてください。");
          return;
        }

        currentDestination = e.latlng;
        userSelectedRoute = false;

        // 目的地住所更新
        const destAddr = await fetchAddress(currentDestination.lat, currentDestination.lng);
        document.getElementById("destAddress").textContent = destAddr;

        const start = marker.getLatLng();
        const dest = currentDestination;

        // 既存ルート削除
        if (routingControl) map.removeControl(routingControl);
        animatedPolylines.forEach(p => map.removeLayer(p.polyline || p));
        animatedPolylines = [];

        // ルート作成（透明でアニメーション）
        routingControl = L.Routing.control({
          waypoints: [start, dest],
          routeWhileDragging: false,
          addWaypoints: false,
          draggableWaypoints: false,
          showAlternatives: true,
          fitSelectedRoutes: false,
          language: "en",
          lineOptions: { styles: [{ color: "transparent", weight: 0, opacity: 0 }] },
          altLineOptions: { styles: [{ color: "transparent", weight: 0, opacity: 0 }] },
          createMarker: (i, wp) => {
            const size = 20;
            const color = i === 0 ? "#00BCD4" : "#800080";
            const m = L.marker(wp.latLng, {
              icon: L.divIcon({
                className: 'custom-marker',
                html: `<div style="width:${size}px;height:${size}px;background:${color};border:2px solid #fff;border-radius:50%;box-shadow:0 0 5px rgba(0,0,0,0.3);"></div>`,
                iconSize: [size, size],
                iconAnchor: [size / 2, size / 2]
              })
            });
            m.on("click", e => {
              showMarkerLabelLeaflet(e, "現在地");
            });
            if (i === 1) m.on('click', () => map.flyTo(m.getLatLng(), 17));
            return m;
          },
          position: 'bottomright'
        })
          .on("routingstart", () => {
            // 手動操作・追尾移動中は無視
            if (userInteracting || programMoving) return;
            const etaElem = document.getElementById("eta");
            // 既に計算結果が表示されている場合は維持
            if (etaElem.textContent && etaElem.textContent !== "---" && !etaElem.textContent.includes("計算中")) return;
            etaElem.textContent = "計算中...";
          })
          .on("routesfound", e => {
            e.routes.forEach(route => translateInstructions(route));
            updateEta(e.routes[0]);
            // 各ルートのアニメーション & クリックでETA更新＆選択色
            e.routes.forEach((route, idx) => {
              const color = idx === 0 ? "#1976d2" : "#f44336";
              const weight = idx === 0 ? 8 : 4;
              const animLine = animateRouteSmooth(route.coordinates, color, weight, 1500);
              // プラットフォーム判定（iPhone 向けにヒット幅を大きめに）
              const isIOS = /iPhone|iPad|iPod/i.test(navigator.userAgent);
              const touchHitWeight = isIOS ? 31 : 31; // iPhone はさらに広く
              // 透明クリック用ライン（タッチ領域を拡大）
              const clickLine = L.polyline(route.coordinates, {
                color: color,
                weight: touchHitWeight,
                opacity: 0.02,      // 完全透明は拾わない場合があるのでごく薄く
                interactive: true,
              }).addTo(map);
              // 保険：要素が取れたら直接 style/属性を設定して確実に当たり判定を広げる
              setTimeout(() => {
                try {
                  const el = clickLine.getElement && clickLine.getElement();
                  if (el) {
                    // SVG path の strokeWidth 等を上書き（Leaflet がつけた属性より確実に効く）
                    el.style.pointerEvents = 'stroke';
                    el.style.cursor = 'pointer';
                    el.style.strokeLinecap = 'round';
                    el.style.strokeWidth = (touchHitWeight) + 'px';
                    // iOS では opacity を微小値にしておく（表示上はほぼ透明）
                    el.style.opacity = 0.02;
                    // さらに属性としても設定（ブラウザ差対策）
                    el.setAttribute('stroke-linecap', 'round');
                    el.setAttribute('stroke-width', String(touchHitWeight));
                  }
                } catch (e) { /* ignore */ }
              }, 0);
              // 選択処理（タッチ / クリック の両方に対応）
              const onSelect = (ev) => {
                updateEta(route);
                userSelectedRoute = true;
                // 選択色反映（選択中：青、他：赤）
                try {
                  animatedPolylines.forEach(p => {
                    if (p.polyline && p.route) {
                      if (p.route === route) p.polyline.setStyle({ color: "#1976d2", weight: 8 });
                      else p.polyline.setStyle({ color: "#f44336", weight: 4 });
                    }
                  });
                } catch (err) {
                  console.warn('route style update error', err);
                }
                if (ev && ev.originalEvent && ev.originalEvent.stopPropagation) ev.originalEvent.stopPropagation();
              };
              // pointerdown / touchstart / click を登録（幅広くカバー）
              clickLine.on('pointerdown touchstart click', onSelect);
              // 任意：ホバー/タッチで少し見せるフィードバック（必要なら）
              clickLine.on('mouseover', () => clickLine.setStyle({ opacity: 0.12 }));
              clickLine.on('mouseout', () => clickLine.setStyle({ opacity: 0.02 }));
              // 元と同じ形式で配列に格納（構造は変えない）
              animatedPolylines.push({ polyline: animLine, route });
              animatedPolylines.push({ polyline: clickLine, route });
            });

            // ルートパネル日本語化
            setTimeout(() => {
              document.querySelectorAll('.leaflet-routing-instruction').forEach(el => {
                let text = el.textContent;
                Object.entries(instructionMap)
                  .sort((a, b) => b[0].length - a[0].length)
                  .forEach(([en, ja]) => { text = text.replace(new RegExp(`\\b${en}\\b`, 'gi'), ja); });
                el.textContent = text;
              });
            }, 100);
          })
          .on("routeselected", e => {
            translateInstructions(e.route);
            updateEta(e.route);
            userSelectedRoute = true;

            // 選択色反映（選択中：青、他：赤）
            animatedPolylines.forEach(p => {
              if (p.route === e.route) p.polyline.setStyle({ color: "#1976d2", weight: 7 });
              else p.polyline.setStyle({ color: "#f44336", weight: 5 });
            });

            setTimeout(() => {
              document.querySelectorAll('.leaflet-routing-instruction').forEach(el => {
                let text = el.textContent;
                Object.entries(instructionMap)
                  .sort((a, b) => b[0].length - a[0].length)
                  .forEach(([en, ja]) => { text = text.replace(new RegExp(`\\b${en}\\b`, 'gi'), ja); });
                el.textContent = text;
              });
            }, 100);
          })
          .on("routingerror", () => {
            document.getElementById("eta").textContent = "経路取得失敗";
          })
          .addTo(map);
        const container = routingControl.getContainer();
        container.style.zIndex = "998";
        let closeBtn = document.querySelector('.leaflet-routing-close');
        if (!closeBtn) {
          closeBtn = document.createElement('a');
          closeBtn.className = 'leaflet-routing-close';
          closeBtn.style.cssText = `
        position:absolute;
        bottom:12.5px;
        right:20px;
        padding:6px 16px;
        height:20px;
        background-color:darkgray;
        font-size:16px;
        font-weight:500;
        color:#333;
        border:1.5px solid gray;
        border-radius:8px;
        box-shadow:0 2px 6px rgba(0,0,0,0.2);
        cursor:pointer;
        z-index:999;
        pointer-events:auto;`;
          closeBtn.onclick = () => {
            const container = routingControl.getContainer();
            container.style.display = container.style.display === 'none' ? 'block' : 'none';
          };
          document.getElementById('map').appendChild(closeBtn);
        }
        navMode = false;
        navModeBtn.textContent = "ナビ開始(車のみ)";
      });

      // ===== ナビキャンセル =====
      cancelNavBtn.addEventListener("click", async () => {
        if (routingControl) {
          map.removeControl(routingControl);
          routingControl = null;
        }
        animatedPolylines.forEach(p => map.removeLayer(p.polyline || p));
        animatedPolylines = [];

        navMode = false;
        navModeBtn.textContent = "ナビ開始(車のみ)";
        currentDestination = null;
        userSelectedRoute = false;

        const closeBtn = document.querySelector('.leaflet-routing-close');
        if (closeBtn) closeBtn.remove();

        if (marker) {
          const currentLatLng = marker.getLatLng();
          const address = await fetchAddress(currentLatLng.lat, currentLatLng.lng);
          document.getElementById("currentAddress").textContent = address;
        }

        const destElem = document.getElementById("destAddress");
        if (destElem) destElem.textContent = "---";
        const etaContainer = document.getElementById("eta");
        if (etaContainer) etaContainer.textContent = "---";
      });
    });



  </script>


</body>

</html>